# Универсальная система сцен

## Обзор

Универсальная система сцен автоматически обрабатывает все аспекты отображения сцен в эпизодах, включая:
- Автоматическое позиционирование персонажей
- Управление анимациями
- Обработка диалогов
- Сборка спрайтов персонажей
- CSS классы для стилизации

## Основные компоненты

### SceneManager (`src/utils/sceneManager.js`)
Центральный менеджер, который обрабатывает все аспекты сцен.

### GameScreen (`src/components/screens/GameScreen.js`)
Использует SceneManager для отображения сцен.

## Автоматическое позиционирование персонажей

Система автоматически определяет позиции персонажей на основе количества говорящих:

### 1 персонаж
- **Позиция**: `center`
- **Пример**: NPC в центре экрана

### 2 персонажа
- **Если есть игрок**: Игрок `left`, NPC `right`
- **Если только NPC**: Первый NPC `left`, второй NPC `right`

### 3 персонажа
- **Если есть игрок**: Игрок `left`, NPC `center`, дополнительный NPC `right`
- **Если только NPC**: Первый NPC `left`, второй NPC `center`, третий NPC `right`

## Структура данных эпизода

### Конфигурация персонажей эпизода
```json
{
  "characters": [
    {
      "id": "teacher",
      "name": "Алексей Петрович",
      "gender": "male",
      "age": "2",
      "appearance": {
        "hairStyle": "short1",
        "hairColor": "brown",
        "dress": "casual",
        "dressPaid": false
      }
    }
  ]
}
```

### Структура сцены
```json
{
  "id": "scene1",
  "background": "sprites/episodes/locations/school/school_building.png",
  "dialogue": [
    {
      "speaker": "narrator",
      "text": "Текст рассказчика",
      "emotion": "neutral"
    },
    {
      "speaker": "teacher",
      "text": "Текст учителя",
      "emotion": "smile1"
    },
    {
      "speaker": "player",
      "text": "Текст игрока",
      "emotion": "normal"
    }
  ],
  "choices": [
    {
      "id": "choice1",
      "text": "Вариант ответа",
      "nextScene": "scene2",
      "effects": {
        "relationship": {
          "teacher": 5
        }
      }
    }
  ]
}
```

## Автоматические функции

### Обработка сцены
```javascript
const processedScene = sceneManager.processScene(sceneData, selectedCharacter);
```

### Получение имени говорящего
```javascript
const speakerName = sceneManager.getSpeakerName(speakerId, selectedCharacter);
```

### Сборка спрайта персонажа
```javascript
const spriteLayers = sceneManager.buildCharacterSprite(characterData, emotion, inventory);
```

### Анимации
```javascript
// Анимация текста
sceneManager.animateText(text, speed, onUpdate);

// Анимация переключения сцен
sceneManager.animateSceneTransition(onUpdate);

// Анимация смены фона
sceneManager.animateBackgroundTransition(onUpdate);

// Анимация появления диалогового окна
sceneManager.animateDialogueEnter(onUpdate);
```

### CSS классы
```javascript
// Классы для диалогового окна
const dialogueClasses = sceneManager.getDialogueBoxClasses(sceneData, textAnimation, sceneAnimation);

// Классы для основной области
const mainAreaClasses = sceneManager.getMainAreaClasses(sceneAnimation);

// Классы для фонового слоя
const backgroundClasses = sceneManager.getBackgroundLayerClasses(sceneAnimation);
```

## Особенности системы

### Автоматическое определение персонажей
- Система анализирует диалоги сцены
- Автоматически определяет, какие персонажи должны быть показаны
- Позиционирует персонажей согласно логике

### Управление эмоциями
- Эмоции персонажей обновляются автоматически на основе диалогов
- Поддерживаются все доступные эмоции для каждого типа персонажа

### Уголки диалоговых окон
- Автоматически добавляются уголки к диалоговым окнам персонажей
- Позиция уголка соответствует позиции говорящего персонажа
- Уголки не добавляются для диалогов рассказчика

### Анимации
- Анимации запускаются только при необходимости
- Переключение сцен анимируется только при реальной смене сцены
- Анимация текста оптимизирована для плавности

## Использование в новых эпизодах

Для создания нового эпизода достаточно:

1. **Создать конфигурацию персонажей** в `episodes/{episodeId}/config.json`
2. **Создать сцены** с диалогами в `episodes/{episodeId}/scenes/{sceneId}.json`
3. **Система автоматически** обработает все остальное

### Пример минимальной сцены
```json
{
  "id": "scene1",
  "background": "sprites/episodes/locations/school/school_building.png",
  "dialogue": [
    {
      "speaker": "teacher",
      "text": "Добро пожаловать на урок!",
      "emotion": "smile1"
    }
  ],
  "choices": [
    {
      "id": "choice1",
      "text": "Спасибо!",
      "nextScene": "scene2"
    }
  ]
}
```

Система автоматически:
- Покажет учителя в центре экрана
- Отобразит его имя вместо ID
- Добавит уголок диалогового окна
- Применит эмоцию "smile1"
- Обработает переход к следующей сцене

## Расширение системы

### Добавление новых типов персонажей
1. Добавить данные персонажа в конфигурацию эпизода
2. Убедиться, что спрайты доступны в `character_sprites.json`
3. Система автоматически обработает нового персонажа

### Добавление новых эмоций
1. Добавить спрайты эмоций в соответствующие папки
2. Обновить `character_sprites.json`
3. Использовать новую эмоцию в диалогах

### Кастомизация позиционирования
Для особых случаев можно расширить метод `autoPositionCharacters` в SceneManager.

## Выявленные проблемы и решения

### 1. Проблема с загрузкой сцен из HTML вместо JSON

#### Описание проблемы
При загрузке эпизодов система пыталась загрузить сцены как HTML файлы вместо JSON, что приводило к ошибкам.

#### Причина
Неправильные пути к файлам сцен в конфигурации эпизода.

#### Решение
Исправить пути в конфигурации эпизода:
```json
{
  "scenes": [
    "scene1.json",
    "scene2.json",
    "scene3.json"
  ]
}
```

### 2. Проблема с инициализацией персонажа игрока

#### Описание проблемы
Персонаж игрока не добавлялся в список персонажей для инициализации отношений.

#### Причина
Отсутствие логики добавления персонажа игрока в список персонажей эпизода.

#### Решение
Добавить персонажа игрока в список персонажей:
```javascript
// В GameScreen.js
const allCharacters = [...episodeConfig.characters];
if (selectedCharacter && !allCharacters.find(char => char.id === selectedCharacter.id)) {
  allCharacters.push(selectedCharacter);
}
```

### 3. Проблема с обновлением спрайтов персонажей

#### Описание проблемы
Спрайты персонажей не обновлялись при изменении внешности.

#### Причина
Отсутствие принудительного обновления при изменении данных персонажа.

#### Решение
Добавить принудительное обновление в `GameScreen`:
```javascript
useEffect(() => {
  if (selectedCharacter) {
    setGameState(prev => ({
      ...prev,
      forceUpdate: Date.now()
    }));
  }
}, [selectedCharacter?.gender, selectedCharacter?.age, selectedCharacter?.appearance]);
```

### 4. Проблема с позиционированием уведомлений

#### Описание проблемы
Уведомления отображались в неправильной позиции на экране.

#### Причина
Неправильные CSS стили для контейнера уведомлений.

#### Решение
Исправить позиционирование в CSS:
```css
.notification-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1000;
  pointer-events: none;
}

.notification {
  pointer-events: auto;
}
```

### 5. Проблема с анимацией текста

#### Описание проблемы
Анимация текста не работала корректно при быстрых переходах между диалогами.

#### Причина
Конфликт между анимациями текста и переходами сцен.

#### Решение
Добавить проверку состояния анимации:
```javascript
const animateText = (text, speed = 60) => {
  if (textAnimation.isAnimating) {
    // Завершить текущую анимацию
    setTextAnimation(prev => ({
      ...prev,
      isComplete: true,
      currentText: prev.fullText
    }));
  }
  
  // Запустить новую анимацию
  sceneManager.animateText(text, speed, setTextAnimation);
};
```

## Рекомендации по разработке

### 1. Структура файлов
- Всегда использовать правильные пути к JSON файлам сцен
- Проверять структуру папок эпизода
- Использовать консистентные имена файлов

### 2. Инициализация
- Всегда добавлять персонажа игрока в список персонажей
- Проверять корректность данных персонажей
- Валидировать конфигурацию эпизода

### 3. Производительность
- Избегать лишних перерендеров спрайтов
- Оптимизировать анимации
- Кэшировать результаты сборки спрайтов

### 4. Отладка
- Использовать консоль браузера для отслеживания ошибок
- Проверять загрузку файлов в Network панели
- Валидировать JSON структуры

## Преимущества

1. **Автоматизация**: Минимум ручной настройки
2. **Консистентность**: Единообразное поведение во всех эпизодах
3. **Масштабируемость**: Легко добавлять новые эпизоды
4. **Производительность**: Оптимизированные анимации
5. **Поддержка**: Централизованная логика упрощает отладку 