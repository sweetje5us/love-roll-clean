# Руководство по устранению неполадок

## Обзор

Этот документ содержит все выявленные проблемы в процессе разработки визуальной новеллы и их решения. Руководство поможет разработчикам избежать подобных проблем в будущем и быстро решить возникающие неполадки.

## Категории проблем

### 1. Система отношений
### 2. Система уведомлений
### 3. Архитектура движка
### 4. Производительность
### 5. Совместимость
### 6. Отладка

---

## 1. Система отношений

### Проблема: Инициализация отношений перезаписывает существующие значения

#### Симптомы
- При старте эпизода отношения сбрасываются к 0
- Локальный прогресс игнорируется
- `getRelationship` возвращает неправильные значения

#### Причина
Неправильный порядок операций в `GameScreen.js`:
1. Сначала инициализировались отношения (все с 0)
2. Затем восстанавливались из локального прогресса

#### Решение
```javascript
// Правильный порядок в GameScreen.js
initializeRelationships(episodeId, allCharacters, playerCharacterId);

// Затем восстановление из локального прогресса
if (currentData.progress && currentData.progress.progress) {
  const relationshipKeys = Object.keys(currentData.progress.progress)
    .filter(key => key.startsWith('relation_'));
  
  relationshipKeys.forEach(key => {
    const targetCharacterId = key.replace('relation_', '');
    const value = currentData.progress.progress[key];
    updateRelationship(playerCharacterId, targetCharacterId, 'friendship', value);
  });
}
```

#### Профилактика
- Всегда проверять порядок операций инициализации
- Добавлять отладочные сообщения для отслеживания значений
- Тестировать восстановление сохранений

---

### Проблема: Отсутствие передачи playerCharacterId

#### Симптомы
- Ошибка "addRelationship is not a function"
- Отношения не изменяются при выборе
- В логах отсутствует playerCharacterId

#### Причина
Отсутствие вызова `setPlayerCharacterId` в `EpisodeManager`.

#### Решение
```javascript
// В GameScreen.js
episodeManager.setPlayerCharacterId(playerCharacterId);

// В EpisodeManager.js
setPlayerCharacterId(characterId) {
  if (this.episodeProgress) {
    this.episodeProgress.playerCharacterId = characterId;
  }
}
```

#### Профилактика
- Всегда передавать playerCharacterId при инициализации
- Проверять наличие playerCharacterId в логах
- Добавлять валидацию параметров

---

### Проблема: Дублирование обновлений отношений

#### Симптомы
- Отношения изменяются несколько раз за один выбор
- Неправильные итоговые значения отношений
- Множественные вызовы reducer

#### Причина
Множественные вызовы `changeRelationship` в `RelationshipsContext`.

#### Решение
```javascript
// В RelationshipsContext.js
const changeRelationship = (characterId, targetId, type, change) => {
  // Если изменение равно 0, не обновляем отношение
  if (change === 0) {
    console.log('Изменение равно 0, пропускаем обновление');
    return;
  }
  
  const currentValue = getRelationship(characterId, targetId, type);
  const newValue = currentValue + change;
  updateRelationship(characterId, targetId, type, newValue);
};
```

#### Профилактика
- Проверять значение изменения перед вызовом
- Использовать `updateRelationship` для восстановления
- Добавлять логирование всех изменений

---

### Проблема: Неправильная проверка условий отношений

#### Симптомы
- Выборы недоступны при правильных отношениях
- Неверные диапазоны для условий
- Логика проверки работает неправильно

#### Причина
Логика проверки условий не учитывала правильные диапазоны отношений.

#### Решение
```javascript
// Правильная проверка условий в checkVariantConditions
if (requirements.min !== undefined && currentValue < requirements.min) {
  return false;
}

if (requirements.max !== undefined && currentValue > requirements.max) {
  return false;
}
```

#### Профилактика
- Тестировать все диапазоны условий
- Валидировать логику проверки
- Добавлять отладочные сообщения

---

## 2. Система уведомлений

### Проблема: Уведомления не отображаются

#### Симптомы
- Уведомления не появляются при изменении отношений
- Отсутствуют уведомления о важных выборах
- Нет визуальной обратной связи

#### Причина
- Неправильное позиционирование в CSS
- Отсутствие `NotificationContext` провайдера

#### Решение
1. Исправить позиционирование в CSS:
```css
.notification-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1000;
  pointer-events: none;
}

.notification {
  pointer-events: auto;
}
```

2. Добавить `NotificationContext` провайдер в `App.js`:
```javascript
import { NotificationProvider } from './contexts/NotificationContext';

function App() {
  return (
    <NotificationProvider>
      {/* остальные провайдеры */}
    </NotificationProvider>
  );
}
```

#### Профилактика
- Проверять наличие всех необходимых провайдеров
- Тестировать CSS стили
- Валидировать z-index значения

---

### Проблема: Неправильное позиционирование уведомлений

#### Симптомы
- Уведомления отображаются в неправильной позиции
- Перекрытие с другими элементами интерфейса
- Проблемы на мобильных устройствах

#### Причина
Неправильные CSS стили для контейнера уведомлений.

#### Решение
```css
.notification-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1000;
  pointer-events: none;
  max-width: 300px;
}

.notification {
  pointer-events: auto;
  margin-bottom: 10px;
}

/* Мобильная адаптация */
@media (max-width: 768px) {
  .notification-container {
    top: 10px;
    right: 10px;
    left: 10px;
    max-width: none;
  }
}
```

#### Профилактика
- Тестировать на разных размерах экрана
- Проверять z-index иерархию
- Валидировать адаптивность

---

## 3. Архитектура движка

### Проблема: Нечеткое разделение ответственности

#### Симптомы
- Компоненты выполняют слишком много функций
- Сложность отладки
- Проблемы с масштабируемостью

#### Причина
Отсутствие четкого разделения ответственности между компонентами.

#### Решение
Рефакторинг архитектуры с разделением на четкие модули:
- `EpisodeManager` - управление эпизодами и прогрессом
- `RelationshipsContext` - управление отношениями
- `SceneManager` - обработка сцен и анимаций
- `NotificationSystem` - система уведомлений

#### Профилактика
- Планировать архитектуру на ранних этапах
- Использовать принцип единственной ответственности
- Регулярно рефакторить код

---

### Проблема: Нецентрализованное управление состоянием

#### Симптомы
- Неконсистентное состояние приложения
- Асинхронные обновления
- Множественные источники истины

#### Причина
Отсутствие централизованного управления состоянием.

#### Решение
Внедрение React Context для централизованного управления состоянием:
```javascript
// Централизованное управление отношениями
const RelationshipsProvider = ({ children }) => {
  const [state, dispatch] = useReducer(relationshipsReducer, initialState);
  // ...
};

// Централизованное управление уведомлениями
const NotificationProvider = ({ children }) => {
  const [notifications, setNotifications] = useState([]);
  // ...
};
```

#### Профилактика
- Использовать React Context для глобального состояния
- Избегать множественных источников истины
- Синхронизировать состояние между компонентами

---

## 4. Производительность

### Проблема: Частые перерендеры компонентов

#### Симптомы
- Медленная работа интерфейса
- Задержки при анимациях
- Высокая нагрузка на CPU

#### Причина
Отсутствие оптимизации React компонентов.

#### Решение
Оптимизация производительности:
```javascript
// Мемоизация компонентов
const GameCharacterAvatar = React.memo(({ characterData, emotion }) => {
  // ...
});

// Оптимизация анимаций
const animateText = useCallback((text, speed) => {
  // Кэширование результатов
}, []);
```

#### Профилактика
- Использовать React.memo для компонентов
- Применять useCallback и useMemo
- Оптимизировать анимации

---

### Проблема: Неэффективные анимации

#### Симптомы
- Анимации работают медленно
- Конфликты между анимациями
- Проблемы с производительностью

#### Причина
Неоптимизированные алгоритмы обработки анимаций.

#### Решение
```javascript
const animateText = (text, speed = 60) => {
  if (textAnimation.isAnimating) {
    // Завершить текущую анимацию
    setTextAnimation(prev => ({
      ...prev,
      isComplete: true,
      currentText: prev.fullText
    }));
  }
  
  // Запустить новую анимацию
  sceneManager.animateText(text, speed, setTextAnimation);
};
```

#### Профилактика
- Кэшировать результаты анимаций
- Избегать конфликтов между анимациями
- Оптимизировать алгоритмы

---

## 5. Совместимость

### Проблема: Несовместимость с существующими сохранениями

#### Симптомы
- Ошибки при загрузке старых сохранений
- Потеря прогресса игрока
- Некорректные данные

#### Причина
Изменения в структуре данных без обеспечения обратной совместимости.

#### Решение
Внедрение системы миграций:
```javascript
// Проверка версии данных
const migrateData = (oldData, version) => {
  switch (version) {
    case 1:
      return migrateToV2(oldData);
    case 2:
      return migrateToV3(oldData);
    default:
      return oldData;
  }
};
```

#### Профилактика
- Всегда обеспечивать обратную совместимость
- Использовать систему версионирования
- Тестировать миграции данных

---

### Проблема: Проблемы с загрузкой файлов

#### Симптомы
- Ошибки загрузки сцен
- Неправильные пути к файлам
- Проблемы с JSON структурами

#### Причина
Неправильные пути к файлам сцен в конфигурации эпизода.

#### Решение
Исправить пути в конфигурации эпизода:
```json
{
  "scenes": [
    "scene1.json",
    "scene2.json",
    "scene3.json"
  ]
}
```

#### Профилактика
- Проверять структуру папок эпизода
- Использовать консистентные имена файлов
- Валидировать JSON структуры

---

## 6. Отладка

### Проблема: Сложность отладки

#### Симптомы
- Отсутствие информации об ошибках
- Сложность поиска проблем
- Недостаточное логирование

#### Причина
Отсутствие системы логирования и недостаточная обработка ошибок.

#### Решение
Внедрение системы отладки:
```javascript
// Централизованное логирование
const debugLog = (component, message, data) => {
  console.log(`[${component}] ${message}`, data);
};

// Обработка ошибок
const handleError = (error, context) => {
  console.error(`[${context}] Ошибка:`, error);
  // Отправка в систему мониторинга
};
```

#### Профилактика
- Добавлять отладочные сообщения
- Использовать централизованное логирование
- Обрабатывать все ошибки

---

## Общие рекомендации

### 1. Планирование
- Тщательно планировать архитектуру на ранних этапах
- Использовать диаграммы и документацию
- Учитывать масштабируемость

### 2. Разработка
- Начинать с простого прототипа
- Добавлять сложность постепенно
- Регулярно рефакторить код

### 3. Тестирование
- Писать тесты параллельно с разработкой
- Использовать автоматизированное тестирование
- Проводить регулярные code reviews

### 4. Документация
- Поддерживать актуальную документацию
- Автоматизировать генерацию документации
- Записывать все решения и их причины

### 5. Мониторинг
- Отслеживать производительность
- Мониторить ошибки пользователей
- Собирать аналитику использования

## Заключение

Это руководство содержит основные проблемы, с которыми мы столкнулись в процессе разработки, и их решения. Регулярное обращение к этому документу поможет избежать подобных проблем в будущем и ускорить процесс разработки.

Помните, что лучший способ избежать проблем - это тщательное планирование, регулярное тестирование и поддержание качественного кода. 