# Механики диалогов в визуальной новелле

## Обзор

Визуальная новелла включает в себя несколько ключевых механик для создания интерактивного опыта:

1. **Система важных выборов** - выборы, влияющие на сюжет и концовки
2. **Система отношений** - динамические отношения между персонажами
3. **Система предметов в диалогах** - дарение и получение предметов между персонажами
4. **Система броска кубиков** - проверка характеристик через броски d20
5. **Система питомцев** - получение и использование питомцев с уникальными способностями
6. **Система отображения эмоций** - визуальное выражение эмоций персонажей
7. **Система уведомлений** - обратная связь для игрока

## 1. Система важных выборов

### Описание
Система важных выборов позволяет создавать ветвящиеся сюжеты, где решения игрока влияют на развитие истории и финальные концовки.

### Как работает
- **Важные выборы** помечаются флагом `important: true` в конфигурации сцены
- Каждый важный выбор сохраняется с метаданными (время, глава, сцена)
- Выборы используются для проверки условий в последующих сценах
- Система поддерживает множественные концовки на основе комбинации выборов

### Структура важного выбора
```json
{
  "id": "moral_choice",
  "text": "Что вы выберете?",
  "important": true,
  "value": "good",
  "description": "Выбор между добром и злом",
  "consequences": ["Влияет на концовку", "Изменяет отношения"]
}
```

### Уведомления
При совершении важного выбора показывается уведомление:
- **Текст**: "*Имя персонажа* это запомнит"
- **Иконка**: ⭐ (звезда)
- **Цвет**: Желтый градиент

### Использование в сценах
```json
{
  "requirements": {
    "importantChoice": {
      "moral_choice": "good"
    }
  }
}
```

## 2. Система отношений

### Описание
Система отношений управляет связями между персонажами и влияет на доступность выборов, диалогов и концовок. Отношения накапливаются в течение игры и сохраняются между сессиями.

### Уровни отношений
Система использует единую шкалу от -100 до 160:

- **Вражда** (-100 до -60): Красный цвет (#dc143c)
- **Неприязнь** (-59 до -20): Оранжевый цвет (#ff6347)
- **Нейтрально** (-19 до 19): Серый цвет (#808080)
- **Дружба** (20 до 59): Зеленый цвет (#32cd32)
- **Близкая дружба** (60 до 100): Темно-зеленый цвет (#228b22)
- **Симпатия** (101 до 120): Розовый цвет (#ff69b4) - только если доступна романтика
- **Любовь** (121 до 140): Ярко-розовый цвет (#ff1493) - только если доступна романтика
- **Страсть** (141 до 160): Темно-розовый цвет (#ff0066) - только если доступна романтика

### Инициализация отношений
Отношения инициализируются при начале эпизода:
- **Начальное значение**: 0 (нейтральные отношения)
- **Инициализация происходит только один раз** для каждого эпизода
- **Защита от множественной инициализации** предотвращает перезапись существующих отношений

### Изменение отношений
Отношения изменяются через эффекты выборов и накапливаются правильно:
```json
{
  "effects": {
    "relationship": {
      "dima": 15,
      "anna": -10
    }
  }
}
```

**Особенности накопления:**
- Каждый эффект обрабатывается только один раз
- Изменения накапливаются: +10, +8, +12, +15, +5, +25 = 75
- Значения ограничиваются диапазоном от -100 до 160
- Сохранение происходит немедленно в localStorage

### Уведомления
При изменении отношений показываются уведомления:
- **Увеличение**: "*Имя персонажа* это понравилось" (зеленое сердце)
- **Уменьшение**: "*Имя персонажа* это не понравилось" (разбитое сердце)

### Бейдж уведомлений
Кнопка "Отношения" получает красный бейдж при изменении отношений, который исчезает при открытии окна отношений.

### Использование в требованиях
```json
{
  "requirements": {
    "relationship": {
      "dima": 50,
      "anna": 20
    }
  }
}
```

### Техническая реализация

#### Файлы системы
- `src/contexts/RelationshipsContext.js` - Основная логика управления отношениями
- `src/utils/episodeManager.js` - Интеграция с менеджером эпизодов

#### Ключевые функции

**`initializeRelationships(episodeId, characters, playerCharacterId, chapterConfig)`**
Инициализирует отношения для эпизода:
- Создает отношения между всеми персонажами
- Устанавливает начальные значения (обычно 0)
- Защищает от множественной инициализации

**`changeRelationship(characterId, targetId, type, change)`**
Изменяет отношение на указанное значение:
- Получает текущее значение через `getRelationship`
- Вычисляет новое значение: `currentValue + change`
- Вызывает `updateRelationship` для сохранения

**`updateRelationship(characterId, targetId, type, value)`**
Обновляет отношение до конкретного значения:
- Обновляет состояние React через `dispatch`
- Немедленно сохраняет в localStorage
- Ограничивает значения от -100 до 160

**`getRelationship(characterId, targetId, type)`**
Получает текущее значение отношения:
- Сначала проверяет в состоянии React
- Затем проверяет в localStorage как fallback
- Возвращает 0 если отношение не найдено

#### Исправления системы

**Проблема 1: Дублирование обработки**
- **Было**: Эффекты отношений обрабатывались дважды в `episodeManager.js`
- **Исправлено**: Убрана дублирующая обработка `case 'relationships'`
- **Результат**: Каждый эффект обрабатывается только один раз

**Проблема 2: Неправильная инициализация**
- **Было**: Отношения инициализировались со значением 50 для Димы
- **Исправлено**: Убрано начальное значение из конфигурации главы 3
- **Результат**: Отношения начинаются с 0

**Проблема 3: Множественная инициализация**
- **Было**: `initializeRelationships` вызывался несколько раз
- **Исправлено**: Добавлена защита от повторной инициализации
- **Результат**: Инициализация происходит только один раз

**Проблема 4: Асинхронное сохранение**
- **Было**: Сохранение происходило через `useEffect` асинхронно
- **Исправлено**: Немедленное сохранение в `updateRelationship`
- **Результат**: Данные сохраняются сразу после изменения

## 3. Система предметов в диалогах

### Описание
Система предметов в диалогах позволяет персонажам дарить и просить предметы у игрока, а также получать предметы от персонажей. Система интегрирована с механиками отношений и важных выборов.

### Основные возможности

#### Получение предметов от персонажей
Персонажи могут дарить предметы игроку по разным причинам:
- В знак дружбы
- За помощь
- Как награду за важные выборы
- Просто так

**Пример в сценарии:**
```json
{
  "choices": [
    {
      "text": "Принять подарок",
      "nextScene": "scene79",
      "effects": {
        "items": {
          "add": ["present"]
        },
        "relationships": {
          "arseniy": 5
        }
      }
    }
  ]
}
```

#### Дарение предметов персонажам
Персонажи могут просить конкретные предметы у игрока. Если у игрока нет нужного предмета, вариант ответа становится неактивным.

**Пример в сценарии:**
```json
{
  "choices": [
    {
      "text": "Дать яблоко",
      "nextScene": "scene81",
      "requiredItem": "apple",
      "effects": {
        "items": {
          "remove": ["apple"]
        },
        "relationships": {
          "arseniy": 8
        }
      }
    },
    {
      "text": "Извини, у меня нет яблока",
      "nextScene": "scene82",
      "effects": {
        "relationships": {
          "arseniy": 0
        }
      }
    }
  ]
}
```

### Проверка доступности выборов

#### Требуемые предметы
Выборы с `requiredItem` автоматически проверяют наличие предмета в инвентаре:

```json
{
  "id": "give_apple",
  "text": "Дать яблоко",
  "requiredItem": "apple",
  "effects": {
    "items": {
      "remove": ["apple"]
    }
  }
}
```

**Логика проверки:**
- Если у игрока есть предмет → выбор активен
- Если у игрока нет предмета → выбор неактивен (показывается серым)
- При неактивном выборе отображается текст: "(требуется: Название предмета)"

#### Поддерживаемые форматы инвентаря
Система поддерживает два формата инвентаря:

1. **Простой формат**: `{ itemId: number }`
2. **Сложный формат**: `{ itemId: { quantity: number, lastAdded: string } }`

### Уведомления о предметах

#### Получение предметов
При получении предмета показывается уведомление:
- **Текст**: "Получен предмет [название предмета]"
- **Иконка**: 🎁 (подарок)
- **Цвет**: Зеленый градиент
- **Тип**: `item_received`

#### Изъятие предметов
При изъятии предмета показывается уведомление:
- **Текст**: "Изъят предмет [название предмета]"
- **Иконка**: ❌ (минус)
- **Цвет**: Серый градиент
- **Тип**: `item_removed`

### Бейдж уведомлений на инвентаре
Кнопка "Инвентарь" получает красный бейдж с иконкой подарка при получении новых предметов. Бейдж автоматически исчезает при открытии инвентаря.

### Интеграция с системой отношений

#### Влияние на отношения
Дарение и получение предметов влияет на отношения:

```json
{
  "effects": {
    "items": {
      "add": ["present"]
    },
    "relationships": {
      "arseniy": 5  // +5 к отношениям за получение подарка
    }
  }
}
```

#### Требования к отношениям для предметов
Некоторые предметы доступны только при определенном уровне отношений:

```json
{
  "choices": [
    {
      "text": "Конечно! Что ты можешь подарить?",
      "nextScene": "scene89",
      "requiredRelationship": {
        "arseniy": "friendship"  // Требуется уровень дружбы
      }
    }
  ]
}
```

### Техническая реализация

#### Файлы системы
- `src/utils/dialogueItemSystem.js` - Основная логика обработки предметов
- `src/utils/episodeManager.js` - Интеграция с менеджером эпизодов
- `src/components/screens/GameScreen.js` - UI для отображения выборов

#### Ключевые функции

**`isChoiceAvailable(choice, inventory)`**
Проверяет доступность выбора на основе требуемых предметов:
```javascript
export function isChoiceAvailable(choice, inventory) {
  if (choice.requiredItem) {
    const itemData = inventory[choice.requiredItem];
    
    if (typeof itemData === 'number') {
      return itemData > 0;
    } else if (itemData && typeof itemData === 'object' && itemData.quantity !== undefined) {
      return itemData.quantity > 0;
    }
    return false;
  }
  return true;
}
```

**`processItemEffects(itemEffects, inventory, showNotification)`**
Обрабатывает эффекты предметов:
```javascript
function processItemEffects(itemEffects, inventory, showNotification) {
  const newInventory = { ...inventory };

  // Добавление предметов
  if (itemEffects.add) {
    const itemsToAdd = Array.isArray(itemEffects.add) ? itemEffects.add : [itemEffects.add];
    itemsToAdd.forEach(itemId => {
      if (!newInventory[itemId]) {
        newInventory[itemId] = { quantity: 0, lastAdded: new Date().toISOString() };
      }
      newInventory[itemId].quantity++;
      
      if (showNotification) {
        const itemName = getItemName(itemId);
        showNotification(`Получен предмет "${itemName}"`, 'success');
      }
    });
  }

  // Удаление предметов
  if (itemEffects.remove) {
    const itemsToRemove = Array.isArray(itemEffects.remove) ? itemEffects.remove : [itemEffects.remove];
    itemsToRemove.forEach(itemId => {
      if (newInventory[itemId] && newInventory[itemId].quantity > 0) {
        newInventory[itemId].quantity--;
        if (newInventory[itemId].quantity === 0) {
          delete newInventory[itemId];
        }
        
        if (showNotification) {
          const itemName = getItemName(itemId);
          showNotification(`Изъят предмет "${itemName}"`, 'info');
        }
      }
    });
  }

  return newInventory;
}
```

### Интеграция с существующими системами

#### Инвентарь
Система интегрирована с `InventoryContext` для управления предметами игрока:
- Автоматическое обновление инвентаря при получении/изъятии предметов
- Проверка наличия предметов для доступности выборов
- Отслеживание новых предметов для бейджа уведомлений

#### Отношения
Использует `RelationshipsContext` для управления отношениями между персонажами:
- Изменение отношений при дарении/получении предметов
- Требования к уровню отношений для доступа к предметам

#### Уведомления
Интегрирована с `NotificationContext` для показа уведомлений о предметах:
- Автоматические уведомления при получении/изъятии предметов
- Бейдж уведомлений на кнопке инвентаря

### Примеры использования

#### Сцена с дарением предмета
```json
{
  "id": "scene77",
  "chapterId": 5,
  "dialogue": [
    {
      "speaker": "arseniy",
      "text": "Вот, например, я хочу подарить тебе небольшой подарок в знак нашего знакомства!",
      "emotion": "delighted"
    }
  ],
  "choices": [
    {
      "text": "Принять подарок",
      "nextScene": "scene79",
      "effects": {
        "items": {
          "add": ["present"]
        },
        "relationships": {
          "arseniy": 5
        }
      }
    }
  ]
}
```

#### Сцена с запросом предмета
```json
{
  "id": "scene78",
  "chapterId": 5,
  "dialogue": [
    {
      "speaker": "arseniy",
      "text": "Кстати, у меня есть небольшая просьба... Можешь ли ты дать мне яблоко?",
      "emotion": "normal"
    }
  ],
  "choices": [
    {
      "text": "Дать яблоко",
      "nextScene": "scene81",
      "requiredItem": "apple",
      "effects": {
        "items": {
          "remove": ["apple"]
        },
        "relationships": {
          "arseniy": 8
        }
      }
    },
    {
      "text": "Извини, у меня нет яблока",
      "nextScene": "scene82",
      "effects": {
        "relationships": {
          "arseniy": 0
        }
      }
    }
  ]
}
```

#### Сцена с требованием отношений
```json
{
  "id": "scene89",
  "chapterId": 5,
  "dialogue": [
    {
      "speaker": "arseniy",
      "text": "У меня есть фея. Это очень ценный питомец, которого я дарю только настоящим друзьям.",
      "emotion": "delighted"
    }
  ],
  "choices": [
    {
      "text": "Принять фею",
      "nextScene": "scene90",
      "requiredRelationship": {
        "arseniy": "friendship"
      },
      "effects": {
        "items": {
          "add": ["fairy"]
        },
        "relationships": {
          "arseniy": 20
        }
      }
    }
  ]
}
```

### Отладка и тестирование

#### Проверка доступности выборов
```javascript
// В консоли браузера
console.log('Инвентарь:', window.getInventory());
console.log('Проверка выбора:', isChoiceAvailable(choice, inventory));
```

#### Тестирование уведомлений
```javascript
// Тест получения предмета
window.addNotification('item_received', {
  message: 'Получен предмет "Подарок"',
  itemName: 'Подарок'
});

// Тест изъятия предмета
window.addNotification('item_removed', {
  message: 'Изъят предмет "Яблоко"',
  itemName: 'Яблоко'
});
```

#### Проверка бейджа инвентаря
- Бейдж появляется при получении новых предметов
- Бейдж исчезает при открытии инвентаря
- Бейдж не появляется при изъятии предметов

### Рекомендации по использованию

#### Дизайн выборов
1. **Всегда предоставляйте альтернативу** - если есть выбор с `requiredItem`, добавьте выбор без требований
2. **Используйте понятные названия предметов** - игрок должен понимать, что требуется
3. **Балансируйте награды** - более ценные предметы должны давать больше отношений

#### Интеграция с сюжетом
1. **Логичность запросов** - персонажи должны просить предметы, которые имеют смысл в контексте
2. **Прогрессия отношений** - более ценные предметы должны быть доступны при более высоких отношениях
3. **Последствия выборов** - отказ дать предмет должен иметь последствия

#### Технические аспекты
1. **Проверяйте существование предметов** - убедитесь, что предметы существуют в `items.json`
2. **Тестируйте граничные случаи** - что происходит при пустом инвентаре
3. **Валидируйте эффекты** - проверяйте корректность `add` и `remove` операций

## 4. Система броска кубиков

### Описание
Система броска кубиков позволяет создавать динамические проверки характеристик персонажа через броски d20. Это добавляет элемент случайности и стратегического планирования в диалоги и выборы.

### Основные характеристики
- **Харизма** - убеждение, социальное взаимодействие
- **Холод** - запугивание, контроль эмоций
- **Чувствительность** - понимание эмоций, эмпатия
- **Коварство** - обман, хитрость
- **Решительность** - сила воли, настойчивость
- **Интеллект** - анализ, решение задач

### Как работает система
1. **Выбор с тегом характеристики** - вариант ответа помечается тегом `[Характеристика]`
2. **Автоматическая проверка** - система выполняет бросок d20 + модификатор характеристики
3. **Сравнение с сложностью** - результат сравнивается с заданной сложностью
4. **Определение результата** - успех/неудача определяет переход к следующей сцене

### Структура проверки в сценарии
```json
{
  "choices": [
    {
      "text": "[Харизма] Убедить продавца дать скидку",
      "diceCheck": {
        "stat": "charisma",
        "difficulty": 15,
        "description": "Убеждение продавца дать скидку",
        "results": {
          "critical_success": "scene_critical_success",
          "success": "scene_success",
          "failure": "scene_failure"
        }
      }
    },
    {
      "text": "[Коварство] Обмануть охранника",
      "diceCheck": {
        "stat": "cunning",
        "difficulty": 18,
        "description": "Обман охранника",
        "results": {
          "critical_success": "scene_critical_success",
          "success": "scene_success",
          "failure": "scene_failure"
        }
      }
    }
  ]
}
```

### Результаты бросков

#### Критический успех (бросок 20)
- **Результат**: Всегда успех, независимо от сложности
- **Описание**: Исключительное мастерство в действии
- **Эффекты**: Дополнительные бонусы, особые результаты

#### Обычный успех (результат ≥ сложности)
- **Результат**: Действие выполнено успешно
- **Описание**: Стандартное выполнение действия
- **Эффекты**: Ожидаемые результаты

#### Обычная неудача (результат < сложности)
- **Результат**: Действие не выполнено
- **Описание**: Неудачная попытка
- **Эффекты**: Отсутствие результата, возможные негативные последствия

#### Критическая неудача (бросок 1)
- **Результат**: Всегда неудача, независимо от модификаторов
- **Описание**: Полный провал действия
- **Эффекты**: Негативные последствия, ухудшение ситуации

### Бонусы от питомцев

#### Бонусы к характеристикам
Питомцы могут давать постоянные бонусы к характеристикам:
```json
{
  "special": {
    "type": "stat",
    "stat_type": "charisma",
    "bonus": 2
  }
}
```

#### Бонусы к результату броска
Питомцы могут давать бонусы к финальному результату броска:
```json
{
  "special": {
    "type": "cube",
    "modificator": 2
  }
}
```

#### Переброс кубика
Некоторые питомцы позволяют перебросить неудачный результат:
```json
{
  "special": {
    "type": "reroll",
    "count": 1
  }
}
```

### Техническая реализация

#### Файлы системы
- `src/utils/diceSystem.js` - Основная логика бросков и проверок
- `src/components/ui/InlineDiceRoll.js` - UI компонент для отображения бросков
- `src/components/ui/InlineDiceRoll.css` - Стили для компонента бросков

#### Ключевые функции

**`performStatCheck(character, statName, difficulty, itemsData)`**
Выполняет проверку характеристики:
```javascript
export function performStatCheck(character, statName, difficulty, itemsData) {
  const baseStat = character[statName] || 10;
  const petStatBonus = getPetStatBonus(character, statName, itemsData);
  const finalStat = getFinalStatValue(baseStat, petStatBonus);
  const modifier = getStatModifier(finalStat);
  
  const roll = rollD20();
  const petCubeBonus = getPetCubeBonus(character, itemsData);
  const total = roll + modifier + petCubeBonus;
  
  return {
    roll,
    modifier,
    petStatBonus,
    petCubeBonus,
    total,
    difficulty,
    success: total >= difficulty,
    criticalSuccess: roll === 20,
    criticalFailure: roll === 1,
    result: getResultType(total, difficulty, roll)
  };
}
```

**`getPetStatBonus(character, statName, itemsData)`**
Получает бонус к характеристике от питомца:
```javascript
export function getPetStatBonus(character, statName, itemsData) {
  if (!character?.petId || !itemsData?.items?.pet) {
    return 0;
  }
  
  const pet = itemsData.items.pet[character.petId];
  if (!pet?.special || pet.special.type !== 'stat') {
    return 0;
  }
  
  const statMapping = {
    'charisma': 'charisma',
    'cold': 'coldness',
    'sensitivity': 'sensitivity',
    'cunning': 'cunning',
    'courage': 'determination',
    'intelligence': 'intelligence'
  };
  
  return pet.special.stat_type === statMapping[statName] ? pet.special.bonus : 0;
}
```

### Интеграция с существующими системами

#### Инвентарь
Система интегрирована с `InventoryContext` для проверки наличия зелья воскрешения для переброса:
- Автоматическая проверка наличия `resurrection_potion`
- Списание зелья при платном перебросе
- Учет бесплатных перебросов от питомцев

#### Персонажи
Использует данные персонажа для:
- Базовых характеристик
- ID питомца для получения бонусов
- Модификаторов характеристик

#### Уведомления
Показывает уведомления о:
- Результатах бросков
- Использовании бонусов питомцев
- Списании зелья воскрешения

### Примеры использования

#### Сцена с проверкой харизмы
```json
{
  "id": "scene101",
  "chapterId": 6,
  "dialogue": [
    {
      "speaker": "nikolay",
      "text": "Попробуй уговорить меня дать тебе дополнительное время на изучение системы бросков кубиков.",
      "emotion": "normal"
    }
  ],
  "choices": [
    {
      "text": "[Харизма] Убедить Николая дать дополнительное время",
      "diceCheck": {
        "stat": "charisma",
        "difficulty": 12,
        "description": "Убеждение Николая дать дополнительное время",
        "results": {
          "critical_success": "scene102",
          "success": "scene103",
          "failure": "scene104"
        }
      }
    }
  ]
}
```

#### Сцена с проверкой интеллекта
```json
{
  "id": "scene105",
  "chapterId": 6,
  "dialogue": [
    {
      "speaker": "nikolay",
      "text": "Я подготовил для тебя небольшую головоломку. Попробуй разгадать её!",
      "emotion": "normal"
    }
  ],
  "choices": [
    {
      "text": "[Интеллект] Попытаться решить головоломку",
      "diceCheck": {
        "stat": "intelligence",
        "difficulty": 14,
        "description": "Решение головоломки Николая",
        "results": {
          "critical_success": "scene106",
          "success": "scene107",
          "failure": "scene108"
        }
      }
    }
  ]
}
```

### Рекомендации по использованию

#### Балансировка сложности
1. **Сложность 5-8** - Легкие проверки для базовых действий
2. **Сложность 9-12** - Средние проверки для обычных ситуаций
3. **Сложность 13-16** - Сложные проверки для важных решений
4. **Сложность 17-20** - Очень сложные проверки для критических моментов

#### Дизайн выборов
1. **Всегда предоставляйте альтернативу** - если есть проверка характеристики, добавьте выбор без проверки
2. **Используйте понятные описания** - игрок должен понимать, что проверяется
3. **Балансируйте последствия** - более сложные проверки должны давать лучшие результаты

#### Интеграция с сюжетом
1. **Логичность проверок** - проверки должны соответствовать контексту ситуации
2. **Прогрессия сложности** - сложность должна расти с развитием сюжета
3. **Последствия результатов** - разные результаты должны вести к разным сценам

### Отладка и тестирование

#### Проверка характеристик персонажа
```javascript
// В консоли браузера
console.log('Характеристики персонажа:', character);
console.log('Питомец:', character.petId);
```

#### Тестирование бросков
```javascript
// Тест проверки характеристики
const result = performStatCheck(character, 'charisma', 15, itemsData);
console.log('Результат проверки:', result);
```

#### Проверка бонусов питомцев
```javascript
// Проверка бонуса к характеристике
const statBonus = getPetStatBonus(character, 'charisma', itemsData);
console.log('Бонус к харизме от питомца:', statBonus);

// Проверка бонуса к броску
const cubeBonus = getPetCubeBonus(character, itemsData);
console.log('Бонус к броску от питомца:', cubeBonus);
```

## 5. Система питомцев

### Описание
Система питомцев позволяет игрокам получать и использовать различных питомцев, которые предоставляют уникальные бонусы и способности. Питомцы влияют на игровой процесс через бонусы к характеристикам, броскам кубиков и специальные способности.

### Типы питомцев

#### По редкости
- **Обычные (common)** - базовые питомцы с простыми способностями
- **Редкие (rare)** - питомцы с улучшенными способностями
- **Мистические (mythical)** - особые питомцы с уникальными способностями
- **Легендарные (legendary)** - самые мощные питомцы

#### По типу способностей
- **Боевые** - дают бонусы к характеристикам
- **Поддерживающие** - предоставляют перебросы и бонусы к броскам
- **Экономические** - увеличивают доходы и скидки
- **Социальные** - улучшают отношения с персонажами

### Структура питомца в items.json
```json
{
  "fairy": {
    "id": "fairy",
    "name": "Фея",
    "description": "Магическое существо",
    "type": "pet",
    "rarity": "mythical",
    "price": {
      "currency": "gems",
      "amount": 25
    },
    "sellPrice": 0,
    "canSell": false,
    "sprite": "sprites/items/pets/fairy.png",
    "scary": false,
    "can_get_in_scenes": true,
    "special": {
      "type": "stat",
      "stat_type": "charisma",
      "bonus": 2
    }
  }
}
```

### Специальные способности питомцев

#### Бонусы к характеристикам
```json
{
  "special": {
    "type": "stat",
    "stat_type": "charisma",
    "bonus": 2
  }
}
```

**Поддерживаемые характеристики:**
- `charisma` - харизма
- `coldness` - холод
- `sensitivity` - чувствительность
- `cunning` - коварство
- `determination` - решительность
- `intelligence` - интеллект

#### Бонусы к броскам кубиков
```json
{
  "special": {
    "type": "cube",
    "modificator": 2
  }
}
```

#### Перебросы кубиков
```json
{
  "special": {
    "type": "reroll",
    "count": 1
  }
}
```

#### Улучшение отношений
```json
{
  "special": {
    "type": "relation",
    "increase": 25
  }
}
```

#### Экономические бонусы
```json
{
  "special": {
    "type": "money",
    "increase": 50
  }
}
```

#### Скидки в магазине
```json
{
  "special": {
    "type": "price",
    "value": 200
  }
}
```

### Получение питомцев

#### Дарение от персонажей
Питомцы могут быть подарены персонажами в знак дружбы или за особые достижения:

```json
{
  "choices": [
    {
      "text": "Принять питомца",
      "nextScene": "scene132",
      "effects": {
        "items": {
          "add": ["fairy"]
        },
        "relationships": {
          "anna": 15
        }
      }
    }
  ]
}
```

#### Покупка в магазине
Питомцы доступны для покупки за монеты или драгоценные камни:

```json
{
  "fairy": {
    "price": {
      "currency": "gems",
      "amount": 25
    }
  }
}
```

#### Награды за достижения
Питомцы могут быть наградой за:
- Завершение глав
- Важные выборы
- Достижение определенного уровня отношений
- Прохождение специальных испытаний

### Использование питомцев в диалогах

#### Плейсхолдеры в тексте
Питомцы могут упоминаться в диалогах через плейсхолдеры:

```json
{
  "dialogue": [
    {
      "speaker": "anna",
      "text": "Какой милый [PET_NAME]! Он такой [PET_REACTION]!",
      "emotion": "happy"
    }
  ]
}
```

**Доступные плейсхолдеры:**
- `[PET_NAME]` - имя питомца
- `[PET_ABILITY]` - описание способности питомца
- `[PET_REACTION]` - реакция персонажа на питомца

#### Автоматическая замена плейсхолдеров
Система автоматически заменяет плейсхолдеры на основе питомца персонажа:

```javascript
const processDialogueText = (text, character) => {
  if (!text || !character) return text;
  
  let processedText = text;
  
  // Заменяем плейсхолдеры питомца
  const petId = character.petId || character.pet?.id;
  const petName = character.petName || character.pet?.name;
  
  if (petId) {
    const pet = Object.values(itemsData.items.pet || {}).find(p => p.id === petId);
    if (pet) {
      const finalPetName = petName || pet.name;
      processedText = processedText.replace(/\[PET_NAME\]/g, finalPetName);
      processedText = processedText.replace(/\[PET_ABILITY\]/g, getPetSpecialText(pet));
      
      if (pet.scary) {
        processedText = processedText.replace(/\[PET_REACTION\]/g, 'испугалась');
      } else {
        processedText = processedText.replace(/\[PET_REACTION\]/g, 'умилилась');
      }
    }
  }
  
  return processedText;
};
```

### Интеграция с системой бросков кубиков

#### Автоматические бонусы
Питомцы автоматически предоставляют бонусы при бросках кубиков:

```javascript
export function getPetStatBonus(character, statName, itemsData) {
  if (!character?.petId || !itemsData?.items?.pet) {
    return 0;
  }
  
  const pet = itemsData.items.pet[character.petId];
  if (!pet?.special || pet.special.type !== 'stat') {
    return 0;
  }
  
  const statMapping = {
    'charisma': 'charisma',
    'cold': 'coldness',
    'sensitivity': 'sensitivity',
    'cunning': 'cunning',
    'courage': 'determination',
    'intelligence': 'intelligence'
  };
  
  return pet.special.stat_type === statMapping[statName] ? pet.special.bonus : 0;
}
```

#### Перебросы кубиков
Питомцы с способностью переброса автоматически предоставляют дополнительные попытки:

```javascript
export function getPetRerollCount(character, itemsData) {
  if (!character?.petId || !itemsData?.items?.pet) {
    return 0;
  }
  
  const pet = itemsData.items.pet[character.petId];
  if (!pet?.special || pet.special.type !== 'reroll') {
    return 0;
  }
  
  return pet.special.count || 0;
}
```

### Управление питомцами

#### Структура данных персонажа
```json
{
  "character": {
    "id": "player1",
    "name": "Игрок",
    "petId": "fairy",
    "petName": "Светлячок"
  }
}
```

#### Получение информации о питомце
```javascript
const getPetInfo = (character, itemsData) => {
  if (!character?.petId || !itemsData?.items?.pet) {
    return null;
  }
  
  return itemsData.items.pet[character.petId];
};
```

#### Проверка наличия питомца
```javascript
const hasPet = (character) => {
  return !!(character?.petId || character?.pet?.id);
};
```

### Уведомления о питомцах

#### Получение питомца
При получении питомца показывается уведомление:
- **Текст**: "Получен питомец [название питомца]"
- **Иконка**: 🐾 (лапка)
- **Цвет**: Зеленый градиент

#### Использование способностей
При использовании способностей питомца показываются уведомления:
- **Бонус к характеристике**: "+2 к харизме от питомца"
- **Переброс кубика**: "Питомец позволяет перебросить кубик"
- **Улучшение отношений**: "Питомец помог улучшить отношения"

### Техническая реализация

#### Файлы системы
- `src/utils/petUtils.js` - Утилиты для работы с питомцами
- `src/utils/diceSystem.js` - Интеграция с системой бросков
- `src/components/screens/GameScreen.js` - Обработка плейсхолдеров

#### Ключевые функции

**`getPetSpecialText(pet)`**
Возвращает описание способности питомца:
```javascript
export function getPetSpecialText(pet) {
  if (!pet?.special) return '';
  
  switch (pet.special.type) {
    case 'stat':
      return `дает +${pet.special.bonus} к ${getStatName(pet.special.stat_type)}`;
    case 'cube':
      return `дает +${pet.special.modificator} к броскам кубиков`;
    case 'reroll':
      return `позволяет перебросить кубик ${pet.special.count} раз`;
    case 'relation':
      return `улучшает отношения на +${pet.special.increase}`;
    case 'money':
      return `увеличивает доходы на +${pet.special.increase}`;
    case 'price':
      return `дает скидку ${pet.special.value} монет`;
    default:
      return '';
  }
}
```

### Примеры использования

#### Сцена получения питомца
```json
{
  "id": "scene129",
  "chapterId": 7,
  "dialogue": [
    {
      "speaker": "anna",
      "text": "Но я все равно подарю тебе питомца - вот тебе обычная Крыса!",
      "emotion": "happy"
    },
    {
      "speaker": "anna",
      "text": "Крыса поможет тебе улучшать отношения на +10 очков. Это хорошее начало!",
      "emotion": "normal"
    }
  ],
  "choices": [
    {
      "text": "Спасибо, я постараюсь лучше!",
      "nextScene": "scene132",
      "effects": {
        "items": {
          "add": ["rat"]
        },
        "relationships": {
          "anna": 5
        }
      }
    }
  ]
}
```

#### Сцена с упоминанием питомца
```json
{
  "id": "scene130",
  "chapterId": 7,
  "dialogue": [
    {
      "speaker": "anna",
      "text": "О, у тебя есть [PET_NAME]! Какой [PET_REACTION]!",
      "emotion": "surprised"
    },
    {
      "speaker": "anna",
      "text": "[PET_ABILITY]. Это очень полезно!",
      "emotion": "happy"
    }
  ]
}
```

### Рекомендации по использованию

#### Дизайн питомцев
1. **Балансировка способностей** - более редкие питомцы должны быть сильнее
2. **Уникальность** - каждый питомец должен иметь уникальную способность
3. **Прогрессия** - питомцы должны открываться по мере развития сюжета

#### Интеграция с сюжетом
1. **Логичность получения** - питомцы должны даваться за осмысленные действия
2. **Влияние на диалоги** - питомцы должны упоминаться в диалогах
3. **Последствия выбора** - разные питомцы должны давать разные преимущества

#### Технические аспекты
1. **Производительность** - кэшировать информацию о питомцах
2. **Совместимость** - поддерживать старые форматы данных
3. **Расширяемость** - легко добавлять новые типы способностей

## 7. Система отображения эмоций

### Описание
Система эмоций позволяет персонажам визуально выражать свои чувства в зависимости от контекста диалога и отношений.

### Поддерживаемые эмоции
- **normal** - обычное выражение
- **happy** - счастье
- **sad** - грусть
- **angry** - злость
- **surprised** - удивление
- **smile1** - легкая улыбка
- **smile2** - широкая улыбка
- **laugh** - смех
- **cry** - плач
- **blush** - смущение

### Использование в диалогах
```json
{
  "dialogue": [
    {
      "speaker": "dima",
      "text": "Привет!",
      "emotion": "happy"
    }
  ]
}
```

### Динамические эмоции
Эмоции могут изменяться в зависимости от:
- Контекста диалога
- Уровня отношений
- Предыдущих выборов игрока
- Важных выборов

### Автоматическое обновление
Система автоматически обновляет эмоции персонажей при:
- Переходе к новому диалогу
- Изменении отношений
- Совершении важных выборов

## 8. Система уведомлений

### Описание
Система уведомлений предоставляет игроку обратную связь о последствиях его выборов.

### Типы уведомлений
1. **relationship_positive** - положительное изменение отношений
2. **relationship_negative** - отрицательное изменение отношений  
3. **important_choice** - совершение важного выбора

### Визуальное оформление
- **Позиция**: Верхний правый угол экрана
- **Анимация**: Плавное появление и исчезновение
- **Автоудаление**: Через 3 секунды
- **Возможность закрытия**: Кнопка X

### Стили уведомлений
- **Полупрозрачный фон** с размытием
- **Цветные полоски** для разных типов
- **Иконки**: Сердце, разбитое сердце, звезда
- **Адаптивность**: Полная ширина на мобильных устройствах

## Техническая реализация

### Компоненты
- `NotificationSystem` - основной компонент уведомлений
- `RelationshipsContext` - управление отношениями
- `InventoryContext` - управление инвентарем и предметами
- `EpisodeManager` - обработка выборов и эффектов
- `SceneManager` - управление эмоциями персонажей
- `DialogueItemSystem` - обработка предметов в диалогах

### Сохранение данных
- **Отношения**: Сохраняются в localStorage
- **Важные выборы**: Сохраняются в прогрессе эпизода
- **Инвентарь**: Сохраняется в localStorage с метаданными предметов
- **Эмоции**: Вычисляются динамически

### Производительность
- Уведомления автоматически удаляются
- Эмоции кэшируются для оптимизации
- Отношения обновляются только при изменениях
- Инвентарь обновляется только при получении/изъятии предметов
- Проверка доступности выборов кэшируется для текущей сцены

## Примеры использования

### Сцена с важным выбором
```json
{
  "id": "scene10",
  "dialogue": [
    {
      "speaker": "dima",
      "text": "Что ты думаешь об этом?",
      "emotion": "normal"
    }
  ],
  "choices": [
    {
      "id": "support_dima",
      "text": "Поддержать Диму",
      "important": true,
      "value": "support",
      "effects": {
        "relationship": {
          "dima": 20
        }
      }
    },
    {
      "id": "criticize_dima", 
      "text": "Покритиковать",
      "important": true,
      "value": "criticize",
      "effects": {
        "relationship": {
          "dima": -15
        }
      }
    }
  ]
}
```

### Сцена с требованиями
```json
{
  "id": "scene15",
  "requirements": {
    "relationship": {
      "dima": 50
    },
    "importantChoice": {
      "support_dima": "support"
    }
  },
  "dialogue": [
    {
      "speaker": "dima",
      "text": "Спасибо за поддержку!",
      "emotion": "happy"
    }
  ]
}
```

## Выявленные проблемы и решения

### 1. Проблема с дублированием обработки отношений

#### Описание проблемы
Система отношений обрабатывала каждый эффект дважды, что приводило к неправильному накоплению изменений.

#### Причина
В `episodeManager.js` было два места обработки отношений:
- `case 'relationship':` - обрабатывал `effects.relationship`
- `case 'relationships':` - обрабатывал `effects.relationships`

В сценах используется формат `"relationship"` (единственное число), но система обрабатывала его дважды.

#### Решение
Убрать дублирующую обработку:
```javascript
// УДАЛЕНО из episodeManager.js:
case 'relationships':
  this.processRelationshipEffects(value);
  break;

// ОСТАВЛЕНО:
case 'relationship':
  // Обработка отношений
  break;
```

**Результат**: Каждый эффект обрабатывается только один раз.

### 2. Проблема с неправильной инициализацией отношений

#### Описание проблемы
Отношения с Димой инициализировались со значением 50 вместо 0.

#### Причина
В конфигурации главы 3 было установлено начальное значение `"dima": 50` в `chapter3/config.json`.

#### Решение
Убрать начальное значение из конфигурации:
```json
// БЫЛО:
"rewards": {
  "experience": 150,
  "coins": 75,
  "relationship": {
    "dima": 50
  }
}

// СТАЛО:
"rewards": {
  "experience": 150,
  "coins": 75
}
```

**Результат**: Отношения начинаются с 0.

### 3. Проблема с множественной инициализацией

#### Описание проблемы
`initializeRelationships` вызывался несколько раз, что приводило к перезаписи существующих отношений.

#### Причина
Отсутствие защиты от повторной инициализации для одного эпизода.

#### Решение
Добавить проверку существующих отношений:
```javascript
// В RelationshipsContext.js
const hasExistingRelationships = Object.keys(existingRelationships).length > 0 && state.episodeId === episodeId;

if (hasExistingRelationships) {
  console.log('Отношения уже инициализированы для этого эпизода, пропускаем');
    return;
  }
```

**Результат**: Инициализация происходит только один раз для каждого эпизода.

### 4. Проблема с асинхронным сохранением

#### Описание проблемы
Отношения сохранялись асинхронно через `useEffect`, что приводило к потере данных при быстрых изменениях.

#### Причина
`useEffect` обновляет состояние асинхронно, но проверка отношений происходила сразу после изменения.

#### Решение
Немедленное сохранение в `updateRelationship`:
```javascript
// В RelationshipsContext.js
const updateRelationship = (characterId, targetId, type, value) => {
  // Сначала обновляем состояние React
  dispatch({
    type: ACTION_TYPES.UPDATE_RELATIONSHIP,
    payload: { characterId, targetId, type, value }
  });
  
  // Затем немедленно сохраняем в localStorage
  setTimeout(() => {
    // Сохранение в localStorage
  }, 0);
};
```

**Результат**: Данные сохраняются сразу после изменения.

### 5. Проблема с чтением устаревших данных

#### Описание проблемы
`getRelationship` читал устаревшие данные из состояния React, игнорируя актуальные данные из localStorage.

#### Причина
Неправильный порядок проверки источников данных.

#### Решение
Упростить логику чтения данных:
```javascript
// В RelationshipsContext.js
const getRelationship = (characterId, targetId, type) => {
  const relationshipKey = `${characterId}_${targetId}_${type}`;
  
  // Сначала проверяем в состоянии React
  let relationship = state.relationships[relationshipKey];
  
  if (relationship) {
    return relationship.value;
}

  // Затем проверяем в localStorage
  try {
    const savedRelationships = localStorage.getItem('gameRelationships');
    if (savedRelationships) {
      const parsed = JSON.parse(savedRelationships);
      relationship = parsed.relationships[relationshipKey];
      
      if (relationship) {
        return relationship.value;
      }
    }
  } catch (error) {
    console.error('Ошибка при чтении отношений из localStorage:', error);
}
  
  return 0;
};
```

**Результат**: Система всегда читает актуальные данные.

### 6. Проблема с передачей playerCharacterId

#### Описание проблемы
В `episodeManager.js` не передавался `playerCharacterId`, что приводило к ошибкам при изменении отношений.

#### Причина
Отсутствие вызова `setPlayerCharacterId` в `EpisodeManager`.

#### Решение
Добавить передачу `playerCharacterId` в `EpisodeManager`:
```javascript
// В GameScreen.js
episodeManager.setPlayerCharacterId(playerCharacterId);

// В EpisodeManager.js
setPlayerCharacterId(characterId) {
  if (this.episodeProgress) {
    this.episodeProgress.playerCharacterId = characterId;
  }
}
```

**Результат**: Система правильно идентифицирует персонажа игрока.

### 7. Проблема с отображением уведомлений

#### Описание проблемы
Уведомления не отображались из-за неправильного позиционирования и отсутствия контекста.

#### Причина
- Неправильное позиционирование в CSS
- Отсутствие `NotificationContext` провайдера

#### Решение
1. Исправить позиционирование в CSS:
```css
.notification-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1000;
}
```

2. Добавить `NotificationContext` провайдер в `App.js`:
```javascript
import { NotificationProvider } from './contexts/NotificationContext';

function App() {
  return (
    <NotificationProvider>
      {/* остальные провайдеры */}
    </NotificationProvider>
  );
      }
```

**Результат**: Уведомления отображаются корректно.

## Итоговые результаты исправлений

После всех исправлений система отношений работает корректно:

1. **Правильная инициализация**: Отношения начинаются с 0
2. **Корректное накопление**: +10, +8, +12, +15, +5, +25 = 75
3. **Немедленное сохранение**: Данные сохраняются сразу после изменения
4. **Защита от дублирования**: Каждый эффект обрабатывается только один раз
5. **Стабильная работа**: Система работает без сбоев и потери данных

## Рекомендации по разработке

### 1. Отладка отношений
- Всегда добавлять отладочные сообщения в `getRelationship` и `changeRelationship`
- Проверять состояние отношений в localStorage
- Использовать консоль браузера для отслеживания изменений

### 2. Тестирование выборов
- Тестировать все варианты выборов с разными уровнями отношений
- Проверять корректность уведомлений
- Валидировать сохранение прогресса

### 3. Производительность
- Избегать множественных обновлений отношений за один выбор
- Кэшировать результаты `getRelationship` где возможно
- Оптимизировать рендеринг уведомлений

### 4. Совместимость
- Поддерживать как глобальную систему отношений, так и локальную
- Обеспечивать обратную совместимость с существующими сохранениями
- Тестировать на разных устройствах и браузерах

## Заключение

Система механик диалогов создает богатый интерактивный опыт, где каждый выбор имеет значение и влияет на развитие истории. Комбинация важных выборов, отношений и эмоций позволяет создавать глубокие и запоминающиеся сюжеты.

Выявленные проблемы и их решения обеспечивают стабильную работу системы и улучшают пользовательский опыт. Регулярное тестирование и отладка помогают поддерживать качество механик на высоком уровне. 